// @eventide/sdk — Node.js SDK for the Eventide event gateway
// Zero dependencies — uses the native fetch API (Node 18+).

/**
 * Spec version constant matching the Go eventproto package.
 */
export const SPEC_VERSION = "agent-events/1.0";

/**
 * Event type constants — mirrors internal/eventproto/types.go.
 * @readonly
 * @enum {string}
 */
export const EventType = Object.freeze({
  // Lifecycle
  TurnStarted: "turn.started",
  TurnCompleted: "turn.completed",
  TurnFailed: "turn.failed",
  TurnCancelled: "turn.cancelled",

  // Message
  MessageDelta: "message.delta",
  MessageCompleted: "message.completed",

  // Tool
  ToolCallStarted: "tool.call.started",
  ToolCallArgsDelta: "tool.call.args.delta",
  ToolCallCompleted: "tool.call.completed",
  ToolCallError: "tool.call.error",

  // State
  StateSnapshot: "state.snapshot",
  StateDelta: "state.delta",

  // Custom
  Custom: "custom",
  CustomComponent: "custom.component",

  // Thread
  ThreadReady: "thread.ready",
});

/**
 * Event level constants — mirrors internal/eventproto/event.go.
 * @readonly
 * @enum {string}
 */
export const Level = Object.freeze({
  Debug: "debug",
  Info: "info",
  Warn: "warn",
  Error: "error",
});

/**
 * Error thrown when the gateway returns a non-2xx response.
 */
export class GatewayError extends Error {
  /**
   * @param {number} status - HTTP status code
   * @param {string} body   - Response body text
   */
  constructor(status, body) {
    super(`gateway responded with ${status}: ${body}`);
    this.name = "GatewayError";
    this.status = status;
    this.body = body;
  }
}

/**
 * @typedef {Object} EventInput
 * @property {string}  threadId    - Thread identifier (required)
 * @property {string}  turnId      - Turn identifier (required)
 * @property {string}  type        - Event type, use EventType constants (required)
 * @property {string}  [level]     - Event level, defaults to Level.Info
 * @property {object}  [payload]   - Event payload, defaults to {}
 * @property {string}  [specVersion] - Spec version, defaults to SPEC_VERSION
 * @property {string}  [eventId]   - Event ID (auto-generated by gateway if omitted)
 * @property {string}  [ts]        - ISO 8601 timestamp (auto-set by gateway if omitted)
 * @property {number}  [seq]       - Sequence number (auto-set by gateway if omitted)
 * @property {string}  [contentType] - Optional content type
 * @property {object}  [source]    - Optional source metadata
 * @property {object}  [trace]     - Optional trace metadata
 * @property {Object.<string,string>} [tags] - Optional tags
 */

/**
 * @typedef {Object} AppendResult
 * @property {string}  eventId    - The assigned event ID
 * @property {number}  seq        - The assigned sequence number
 * @property {string}  [streamId] - Redis stream ID
 * @property {boolean} [duplicated] - Whether the event was a duplicate
 */

/**
 * Client for the Eventide event gateway.
 *
 * @example
 * const client = new GatewayClient("http://127.0.0.1:18081");
 * await client.append({
 *   threadId: "t1",
 *   turnId:   "turn1",
 *   type:     EventType.TurnStarted,
 *   payload:  { input: { message: "hello" } },
 * });
 */
export class GatewayClient {
  /**
   * @param {string} baseURL          - Gateway base URL, e.g. "http://127.0.0.1:18081"
   * @param {object} [options]
   * @param {number} [options.timeoutMs=10000] - Request timeout in milliseconds
   */
  constructor(baseURL, options = {}) {
    this.baseURL = baseURL.replace(/\/+$/, "");
    this.timeoutMs = options.timeoutMs ?? 10_000;
  }

  /**
   * Append a single event to the gateway.
   *
   * @param {EventInput} event
   * @returns {Promise<AppendResult>}
   * @throws {GatewayError} on non-2xx response
   */
  async append(event) {
    const body = JSON.stringify({
      event: {
        spec_version: event.specVersion ?? SPEC_VERSION,
        event_id: event.eventId ?? "",
        thread_id: event.threadId,
        turn_id: event.turnId,
        seq: event.seq ?? 0,
        ts: event.ts ?? "",
        type: event.type,
        level: event.level ?? Level.Info,
        payload: event.payload ?? {},
        content_type: event.contentType,
        source: event.source,
        trace: event.trace,
        tags: event.tags,
      },
    });

    const controller = new AbortController();
    const timer = setTimeout(() => controller.abort(), this.timeoutMs);

    try {
      const resp = await fetch(`${this.baseURL}/events:append`, {
        method: "POST",
        headers: { "content-type": "application/json" },
        body,
        signal: controller.signal,
      });

      if (!resp.ok) {
        const text = await resp.text();
        throw new GatewayError(resp.status, text);
      }

      const result = await resp.json();
      return {
        eventId: result.event_id,
        seq: result.seq,
        streamId: result.stream_id,
        duplicated: result.duplicated,
      };
    } finally {
      clearTimeout(timer);
    }
  }

  /**
   * Convenience: append multiple events sequentially.
   *
   * @param {EventInput[]} events
   * @returns {Promise<AppendResult[]>}
   */
  async appendAll(events) {
    const results = [];
    for (const event of events) {
      results.push(await this.append(event));
    }
    return results;
  }
}

/**
 * Convenience helper to wrap component props in the format expected by json-render
 * 
 * @param {string} component - Name of the registered component (e.g. 'DataTable')
 * @param {object} props - Properties to pass to the component
 * @returns {object} JSON payload with __jr__ marker
 */
export function componentPayload(component, props = {}) {
  return {
    "__jr__": true,
    component,
    props
  };
}
